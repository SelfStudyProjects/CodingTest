'''
* 문제 설명
정수(또는 해시 가능한 값)로 이루어진 두 리스트 arr1, arr2가 주어질 때, 두 리스트의 교집합(공통 원소)을
효율적으로 찾아 리스트로 반환하세요. 결과의 순서는 문제 요구에 따라 유지하거나(예: arr2 순서 유지) 정렬할 수 있습니다.

* 알고리즘/자료구조 구체적 설명 — 해시 테이블(집합)과 교집합 찾기

* 해시 테이블(집합)의 정의 및 장점:
정의: 키를 해시 함수로 매핑해 내부 버킷에 저장하는 자료구조로, 평균적으로 삽입/조회/삭제가 O(1) 시간. 파이썬의 set, dict가 대표적.
장점: 큰 데이터에서 존재 여부를 빠르게 확인할 수 있어 교집합, 중복 제거, 빈도 계산 등에 유리함.

* 본 문제에서의 동작 원리:
arr1을 집합으로 변환(O(n) 시간).
arr2를 순회하면서 각 원소가 집합에 있는지 O(1) 평균으로 검사하고, 참이면 결과에 추가 → 총 O(m) 시간.
따라서 전체 시간복잡도는 O(n + m).
공간복잡도: O(n) — arr1 크기의 집합 저장 필요.

* 중복 처리 옵션:
유일한 값만 반환하려면 result도 집합으로 만들거나, 처음부터 두 집합의 교집합(set(arr1) & set(arr2))을 사용하면 됨(단, 순서 보존 불가).
등장 횟수까지 고려하려면 카운터(예: collections.Counter)를 사용해 빈도 기반 교집합(교집합의 다중집합 버전)을 만들 수 있음.

구조: [표현식 for 변수 in 반복가능한객체 if 조건]
이 코드는 **리스트 컴프리헨션(list comprehension)**이라고 불립니다.
리스트 컴프리헨션은 기존 반복문과 조건문을 한 줄로 간결하게 써서 새로운 리스트를 만드는 파이썬의 대표적인 구문
'''

def find_common_elements(arr1, arr2):
    hash_set = set(arr1)                       # arr1의 원소를 해시셋에 저장
    result = [x for x in arr2 if x in hash_set]# arr2 순서 유지하면서 공통 원소 수집
    return result

print(find_common_elements([1, 2, 3, 4], [3, 4, 5, 6]))  # [3, 4]