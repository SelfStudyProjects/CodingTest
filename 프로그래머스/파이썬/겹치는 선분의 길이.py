# 1. 카운팅 배열 초기화:
# 좌표 범위 -100 ~ 100에 대해, 1단위 구간을 셀 배열을 만든다.
# -100을 인덱스 0으로 매핑하기 위해 모든 좌표에 +100을 오프셋으로 사용.
# arr[i]는 (i-100)부터 (i-100+1)까지의 구간이 겹치는 선분 개수를 저장.
# 2. 각 선분을 순회하며 카운팅 배열 업데이트:
# 주어진 세 선분 각각에 대해, 해당 선분이 덮는 1단위 구간의 카운트를 1 증가시킨다.
# 총 200개의 1단위 구간 ([N, N+1])을 표현
# line_start부터 line_end-1까지의 모든 정수 구간에 대해
# 오프셋을 적용하여 arr의 해당 인덱스 값을 증가시킨다.
# 예: 선분 [0, 2] -> 인덱스 (0+100)=100, (1+100)=101 에 대해 카운트 증가.
# 이는 구간 [0,1]과 [1,2]에 선분이 존재함을 표시.
# 3. 겹치는 총 길이 계산:
# 카운팅 배열을 순회하면서, 값이 2 이상인 구간의 개수를 센다.
# 이 개수가 곧 '두 개 이상의 선분이 겹치는 부분의 총 길이'가 된다.
# 해당 1단위 구간이 2개 이상의 선분에 겹친다면
# 겹치는 길이에 1을 더한다 (1단위 길이이므로) 

def solution(lines):
    arr = [0] * 200
    for line_start, line_end in lines:
        for i in range(line_start + 100, line_end + 100): # 인덱스 값을 0부터 시작할려고 이렇게 함, 튜플에다가 +100하면 해당 튜플 속 요소들에 모두 
        # 100씩 더해짐
            arr[i] += 1
    total_overlap_length = 0
    for count in arr:
        if count >= 2:
            total_overlap_length += 1    
    return total_overlap_length